mod behviour;
mod codec;
mod upgrade;
mod stream;
pub mod topic;
mod wire;

pub use topic::Topic;
use {futures::Stream, thiserror::Error};

#[derive(Debug, Error)]
pub enum Error {}

/// Represents a network level event that is emitted
/// by the networking module. Events are ordered by their
/// occurance time and accessed by polling the network stream.
#[derive(Debug, PartialEq, Eq)]
pub enum Event {}

/// tbd
#[derive(Debug, Default)]
pub struct Config {}

/// This type is the entrypoint to using the network API.
///
/// It is used to configure general network settings such as
/// the underlying transport protocol, encryption scheme, dns
/// lookup and other non-topic specific configuration values.
///
/// An instance of this type is used to join topics and acquire
/// instances of types for interacting with individul topics.
pub struct Network {}

impl Default for Network {
  fn default() -> Self {
    Self::new(Config::default())
  }
}

impl Network {
  /// Instanciates a network object with non-default configuration.
  ///
  /// We want to strive to minimize the instances where non-default
  /// network settings are used (outside of unit tests). If you find
  /// yourself repeatedly setting a config value when instantiating
  /// the network, consider making it a default value of the config
  /// object.
  pub fn new(_config: Config) -> Self {
    Self {}
  }

  /// Joins a new topic on this network.
  ///
  /// The config value specifies mainly the topic name and
  /// a list of bootstrap peers. If the bootstrap list is empty
  /// then this node will not dial into any peers but listen on
  /// incoming connections on that topic. It will not receive or
  /// send any values unless at least one other node connects to it.
  pub async fn join(
    &mut self,
    _config: topic::Config,
  ) -> Result<&Topic, Error> {
    todo!();
  }
}

/// Used to poll for events generated by the network.
impl Stream for Network {
  type Item = Event;

  fn poll_next(
    self: std::pin::Pin<&mut Self>,
    _: &mut std::task::Context<'_>,
  ) -> std::task::Poll<Option<Self::Item>> {
    todo!()
  }
}
